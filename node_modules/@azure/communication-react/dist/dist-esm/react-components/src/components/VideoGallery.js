// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { concatStyleSets, ContextualMenu, LayerHost, mergeStyles, Stack } from '@fluentui/react';
import React, { useCallback, useMemo, useRef } from 'react';
import { smartDominantSpeakerParticipants } from '../gallery';
import { useIdentifiers } from '../identifiers/IdentifierProvider';
import { useLocale } from '../localization';
import { useTheme } from '../theming';
import { GridLayout } from './GridLayout';
import { _RemoteVideoTile } from './RemoteVideoTile';
import { ResponsiveHorizontalGallery } from './ResponsiveHorizontalGallery';
import { HORIZONTAL_GALLERY_BUTTON_WIDTH, HORIZONTAL_GALLERY_GAP } from './styles/HorizontalGallery.styles';
import { LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM, SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM, floatingLocalVideoModalStyle, floatingLocalVideoTileStyle, horizontalGalleryContainerStyle, horizontalGalleryStyle, layerHostStyle, localVideoTileContainerStyle, videoGalleryContainerStyle, videoGalleryOuterDivStyle, localVideoTileOuterPaddingPX, SMALL_FLOATING_MODAL_SIZE_PX, LARGE_FLOATING_MODAL_SIZE_PX } from './styles/VideoGallery.styles';
import { isNarrowWidth, _useContainerHeight, _useContainerWidth } from './utils/responsive';
import { LocalScreenShare } from './VideoGallery/LocalScreenShare';
import { RemoteScreenShare } from './VideoGallery/RemoteScreenShare';
import { useId } from '@fluentui/react-hooks';
import { localVideoTileWithControlsContainerStyle, LOCAL_VIDEO_TILE_ZINDEX } from './styles/VideoGallery.styles';
import { _ModalClone } from './ModalClone/ModalClone';
import { _LocalVideoTile } from './LocalVideoTile';
// Currently the Calling JS SDK supports up to 4 remote video streams
const DEFAULT_MAX_REMOTE_VIDEO_STREAMS = 4; // Set aside only 6 dominant speakers for remaining audio participants
const MAX_AUDIO_DOMINANT_SPEAKERS = 6;
const DRAG_OPTIONS = {
    moveMenuItemText: 'Move',
    closeMenuItemText: 'Close',
    menu: ContextualMenu,
    keepInBounds: true
}; // Manually override the max position used to keep the modal in the bounds of its container.
// This is a workaround for: https://github.com/microsoft/fluentui/issues/20122
// Because our modal starts in the bottom right corner, we can say that this is the max (i.e. rightmost and bottomost)
// position the modal can be dragged to.
const modalMaxDragPosition = {
    x: localVideoTileOuterPaddingPX,
    y: localVideoTileOuterPaddingPX
};
/**
 * VideoGallery represents a layout of video tiles for a specific call.
 * It displays a {@link VideoTile} for the local user as well as for each remote participant who has joined the call.
 *
 * @public
 */
export const VideoGallery = (props) => {
    var _a, _b, _c, _d;
    const { localParticipant, remoteParticipants = [], localVideoViewOptions, remoteVideoViewOptions, dominantSpeakers, onRenderLocalVideoTile, onRenderRemoteVideoTile, onCreateLocalStreamView, onDisposeLocalStreamView, onCreateRemoteStreamView, onDisposeRemoteStreamView, styles, layout, onRenderAvatar, showMuteIndicator, maxRemoteVideoStreams = DEFAULT_MAX_REMOTE_VIDEO_STREAMS, showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps } = props;
    const ids = useIdentifiers();
    const theme = useTheme();
    const localeStrings = useLocale().strings.videoGallery;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const shouldFloatLocalVideo = !!(layout === 'floatingLocalVideo' && remoteParticipants.length > 0);
    const shouldFloatNonDraggableLocalVideo = !!(showCameraSwitcherInLocalPreview && shouldFloatLocalVideo);
    const containerRef = useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const containerHeight = _useContainerHeight(containerRef);
    const isNarrow = containerWidth ? isNarrowWidth(containerWidth) : false;
    const visibleVideoParticipants = useRef([]);
    const visibleAudioParticipants = useRef([]);
    const modalWidth = isNarrow ? SMALL_FLOATING_MODAL_SIZE_PX.width : LARGE_FLOATING_MODAL_SIZE_PX.width;
    const modalHeight = isNarrow ? SMALL_FLOATING_MODAL_SIZE_PX.height : LARGE_FLOATING_MODAL_SIZE_PX.height; // The minimum drag position is the top left of the video gallery. i.e. the modal (PiP) should not be able
    // to be dragged offscreen and these are the top and left bounds of that calculation.
    const modalMinDragPosition = useMemo(() => containerWidth && containerHeight ? {
        // We use -containerWidth/Height because our modal is positioned to start in the bottom right,
        // hence (0,0) is the bottom right of the video gallery.
        x: -containerWidth + modalWidth + localVideoTileOuterPaddingPX,
        y: -containerHeight + modalHeight + localVideoTileOuterPaddingPX
    } : undefined, [containerHeight, containerWidth, modalHeight, modalWidth]);
    visibleVideoParticipants.current = smartDominantSpeakerParticipants({
        participants: (_a = remoteParticipants === null || remoteParticipants === void 0 ? void 0 : remoteParticipants.filter(p => { var _a; return (_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable; })) !== null && _a !== void 0 ? _a : [],
        dominantSpeakers,
        lastVisibleParticipants: visibleVideoParticipants.current,
        maxDominantSpeakers: maxRemoteVideoStreams
    }).slice(0, maxRemoteVideoStreams);
    // This set will be used to filter out participants already in visibleVideoParticipants
    const visibleVideoParticipantsSet = new Set(visibleVideoParticipants.current.map(p => p.userId));
    visibleAudioParticipants.current = smartDominantSpeakerParticipants({
        participants: (_b = remoteParticipants === null || remoteParticipants === void 0 ? void 0 : remoteParticipants.filter(p => !visibleVideoParticipantsSet.has(p.userId))) !== null && _b !== void 0 ? _b : [],
        dominantSpeakers,
        lastVisibleParticipants: visibleAudioParticipants.current,
        maxDominantSpeakers: MAX_AUDIO_DOMINANT_SPEAKERS
    });
    /**
     * Utility function for memoized rendering of LocalParticipant.
     */
    const localVideoTile = useMemo(() => {
        var _a, _b;
        if (onRenderLocalVideoTile) {
            return onRenderLocalVideoTile(localParticipant);
        }
        const localVideoTileStyles = concatStyleSets(shouldFloatLocalVideo ? floatingLocalVideoTileStyle : {}, {
            root: {
                borderRadius: theme.effects.roundedCorner4
            }
        }, styles === null || styles === void 0 ? void 0 : styles.localVideo);
        const initialsName = !localParticipant.displayName ? strings.displayNamePlaceholder : localParticipant.displayName;
        return React.createElement(Stack, { key: "local-video-tile-key", tabIndex: 0, "aria-label": strings.localVideoMovementLabel, role: 'dialog' },
            React.createElement(_LocalVideoTile, { userId: localParticipant.userId, onCreateLocalStreamView: onCreateLocalStreamView, onDisposeLocalStreamView: onDisposeLocalStreamView, isAvailable: (_a = localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable, isMuted: localParticipant.isMuted, renderElement: (_b = localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.renderElement, displayName: isNarrow ? '' : strings.localVideoLabel, initialsName: initialsName, localVideoViewOptions: localVideoViewOptions, onRenderAvatar: onRenderAvatar, showLabel: !(shouldFloatLocalVideo && isNarrow), showMuteIndicator: showMuteIndicator, showCameraSwitcherInLocalPreview: showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps: localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel: strings.localVideoCameraSwitcherLabel, localVideoSelectedDescription: strings.localVideoSelectedDescription, styles: localVideoTileStyles }));
    }, [isNarrow, localParticipant, localVideoCameraCycleButtonProps, localVideoViewOptions, onCreateLocalStreamView, onDisposeLocalStreamView, onRenderAvatar, onRenderLocalVideoTile, shouldFloatLocalVideo, showCameraSwitcherInLocalPreview, showMuteIndicator, strings.localVideoCameraSwitcherLabel, strings.localVideoLabel, strings.localVideoMovementLabel, strings.localVideoSelectedDescription, strings.displayNamePlaceholder, styles === null || styles === void 0 ? void 0 : styles.localVideo, theme.effects.roundedCorner4]);
    const defaultOnRenderVideoTile = useCallback((participant, isVideoParticipant) => {
        const remoteVideoStream = participant.videoStream;
        return React.createElement(_RemoteVideoTile, Object.assign({ key: participant.userId }, participant, { onCreateRemoteStreamView: isVideoParticipant ? onCreateRemoteStreamView : undefined, onDisposeRemoteStreamView: isVideoParticipant ? onDisposeRemoteStreamView : undefined, isAvailable: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.isAvailable : false, isReceiving: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.isReceiving : false, renderElement: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.renderElement : undefined, remoteVideoViewOptions: isVideoParticipant ? remoteVideoViewOptions : undefined, onRenderAvatar: onRenderAvatar, showMuteIndicator: showMuteIndicator }));
    }, [onCreateRemoteStreamView, onDisposeRemoteStreamView, remoteVideoViewOptions, onRenderAvatar, showMuteIndicator]);
    const videoTiles = onRenderRemoteVideoTile ? visibleVideoParticipants.current.map(participant => onRenderRemoteVideoTile(participant)) : visibleVideoParticipants.current.map((participant) => {
        return defaultOnRenderVideoTile(participant, true);
    });
    const audioTiles = onRenderRemoteVideoTile ? visibleAudioParticipants.current.map(participant => onRenderRemoteVideoTile(participant)) : visibleAudioParticipants.current.map((participant) => {
        return defaultOnRenderVideoTile(participant, false);
    });
    const screenShareParticipant = remoteParticipants.find(participant => { var _a; return (_a = participant.screenShareStream) === null || _a === void 0 ? void 0 : _a.isAvailable; });
    const screenShareActive = screenShareParticipant || (localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.isScreenSharingOn);
    const createGridTiles = () => {
        return videoTiles.length > 0 ? videoTiles : audioTiles;
    };
    const gridTiles = createGridTiles();
    const createHorizontalGalleryTiles = () => {
        if (screenShareActive) {
            // If screen sharing is active, assign video and audio participants as horizontal gallery participants
            return videoTiles.concat(audioTiles);
        }
        else {
            // If screen sharing is not active, then assign all video tiles as grid tiles.
            // If there are no video tiles, then assign audio tiles as grid tiles.
            return videoTiles.length > 0 ? audioTiles : [];
        }
    };
    const horizontalGalleryTiles = createHorizontalGalleryTiles();
    if (!shouldFloatLocalVideo && localVideoTile) {
        gridTiles.push(localVideoTile);
    }
    const localScreenShareStreamComponent = React.createElement(LocalScreenShare, { localParticipant: localParticipant });
    const remoteScreenShareComponent = screenShareParticipant && React.createElement(RemoteScreenShare, Object.assign({}, screenShareParticipant, { renderElement: (_c = screenShareParticipant.screenShareStream) === null || _c === void 0 ? void 0 : _c.renderElement, onCreateRemoteStreamView: onCreateRemoteStreamView, onDisposeRemoteStreamView: onDisposeRemoteStreamView, isReceiving: (_d = screenShareParticipant.screenShareStream) === null || _d === void 0 ? void 0 : _d.isReceiving }));
    const horizontalGalleryPresent = horizontalGalleryTiles && horizontalGalleryTiles.length > 0;
    const layerHostId = useId('layerhost');
    return React.createElement("div", { "data-ui-id": ids.videoGallery, ref: containerRef, className: mergeStyles(videoGalleryOuterDivStyle, styles === null || styles === void 0 ? void 0 : styles.root) },
        shouldFloatLocalVideo && !shouldFloatNonDraggableLocalVideo && localVideoTile && (horizontalGalleryPresent ? React.createElement(Stack, { className: mergeStyles(localVideoTileContainerStyle(theme, isNarrow)) }, localVideoTile) : React.createElement(_ModalClone, { isOpen: true, isModeless: true, dragOptions: DRAG_OPTIONS, styles: floatingLocalVideoModalStyle(theme, isNarrow), layerProps: {
                hostId: layerHostId
            }, maxDragPosition: modalMaxDragPosition, minDragPosition: modalMinDragPosition }, localVideoTile)),
        shouldFloatNonDraggableLocalVideo && localVideoTile && remoteParticipants.length > 0 && React.createElement(Stack, { className: mergeStyles(localVideoTileWithControlsContainerStyle(theme, isNarrow), {
                boxShadow: theme.effects.elevation8,
                zIndex: LOCAL_VIDEO_TILE_ZINDEX
            }) }, localVideoTile),
        React.createElement(Stack, { horizontal: false, styles: videoGalleryContainerStyle },
            screenShareParticipant ? remoteScreenShareComponent : (localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.isScreenSharingOn) ? localScreenShareStreamComponent : React.createElement(GridLayout, { key: "grid-layout", styles: styles === null || styles === void 0 ? void 0 : styles.gridLayout }, gridTiles),
            horizontalGalleryPresent && React.createElement("div", { style: {
                    paddingTop: '0.5rem'
                } },
                React.createElement(ResponsiveHorizontalGallery, { key: "responsive-horizontal-gallery", containerStyles: horizontalGalleryContainerStyle(shouldFloatLocalVideo, isNarrow), horizontalGalleryStyles: concatStyleSets(horizontalGalleryStyle(isNarrow), styles === null || styles === void 0 ? void 0 : styles.horizontalGallery), childWidthRem: isNarrow ? SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.width : LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.width, buttonWidthRem: HORIZONTAL_GALLERY_BUTTON_WIDTH, gapWidthRem: HORIZONTAL_GALLERY_GAP }, horizontalGalleryTiles)),
            React.createElement(LayerHost, { id: layerHostId, className: mergeStyles(layerHostStyle) })));
};
//# sourceMappingURL=VideoGallery.js.map